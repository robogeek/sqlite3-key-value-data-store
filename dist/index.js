import util from 'node:util';
import sqlite3 from 'sqlite3';
import { selectors2where } from './finder.js';
// import sqdb from './sqdb.js';
// PROBLEM - @akashacms/plugns-tagged-content
// is using PouchDB which then brought in
// a lot of unwanted dependencies in the
// LevelDown arena.
//
// It should be possible to use SQLITE3 to
// implement a key/value store.  This could
// also eliminate the need for KeyV in another
// plugin.
//
// Another goal is to spin this off into its
// own package that might be of broad interest.
// Simple key/value store on SQLITE3.
// Support multiple stores - named
// Each store has its own table
// CREATE TABLE kvs${NAME} (
//    key TEXT
//    value JSON
// )
// The key column needs an index and to
// be unique
// Is there a way to ALTER TABLE to add
// columns based on a JSON field?
// To replace pouchdb use in tagged-content
// there's a need for queries on fields of
// the JSON object
// This encapsulates an object with put/get/delete
// methods for the key-value-store.
// If ALTER TABLE is useful then an API is
// needed for adding a queryable column.
// https://github.com/kujirahand/node-sqlite-kvs
// That's a simplistic KVS which can be used
// as a model
// Once this is complete it can be spun off to
// a standalone module.
// CREATE TABLE kvs{NAME} (
//     key TEXT PRIMARY KEY,
//     value JSON // isJSON=true
// ) WITHOUT ROWID;
// sqlite> SELECT 
//       vpath,
//       json_extract(info, '$.renderPath') as renderPath2 
// FROM DOCUMENTS
// WHERE renderPath2 LIKE '%index.html';
////////////////// Opening Database connection
// let DB: sqlite3.Database;
/**
 * Use an existing DB
 * @param db
 */
// export function useDB(db: sqlite3.Database) {
//     DB = db;
// }
/**
 * Open a database connection to the
 * named location.
 *
 * @param dburl
 */
// export function open(dburl: string) {
//     DB = new sqlite3.Database(dburl);
// }
///////////////////// Create a table
// export async function kvtable(name: string) {
//     const tablenm = `kv${name}`;
//     const indexnm = `kv_index_${name}`;
//     const result = await DB.exec(`
//         CREATE TABLE ${tablenm} (
//             key TEXT PRIMARY KEY,
//             value TEXT
//         ) WITHOUT ROWID;
//         CREATE UNIQUE INDEX ${indexnm}
//             ON ${tablenm} (key);
//     `);
//     return new SQ3DataStore(DB, tablenm);
// }
export class SQ3DataStore {
    #DB;
    #tablenm;
    #indexnm;
    constructor(DB, tablenm) {
        if (typeof DB === 'object'
            && DB instanceof sqlite3.Database) {
            this.#DB = DB;
        }
        else if (typeof DB === 'string') {
            this.#DB = new sqlite3.Database(DB);
        }
        else {
            this.#DB = new sqlite3.Database(':memory:');
        }
        // this.#DB.on('trace', (sql) => {
        //     console.log(`TRACE: ${sql}`);
        // });
        this.#tablenm = tablenm;
        this.#indexnm = `kv_index_${tablenm}`;
        this.#DB.exec(`
            CREATE TABLE ${tablenm} (
                key TEXT PRIMARY KEY,
                value TEXT
            ) WITHOUT ROWID;
            CREATE UNIQUE INDEX ${this.#indexnm}
                ON ${this.#tablenm} (key);
        `);
    }
    get DB() { return this.#DB; }
    // This can be useful for debugging.
    // This SQLITE query retrieves the table listing
    // all the existing tables.
    // async tables() {
    //     const rows = await new Promise((resolve, reject) => {
    //         this.#DB.all(`
    //             SELECT * FROM sqlite_master;
    //         `, {},
    //         (err, rows) => {
    //             if (err) {
    //                 console.error(`put ERROR `, err.stack);
    //                 reject(err);
    //             } else {
    //                 resolve(rows);
    //             }
    //         });
    //     });
    //     return rows;
    // }
    async put(key, value) {
        // insert into ...
        // console.log(`before get ${key}`);
        const update = await this.get(key);
        // console.log(`put ${key} got value ${util.inspect(update)}`);
        if (update) {
            return this.update(key, value);
        }
        // console.log(`to put ${key}`, value);
        await new Promise((resolve, reject) => {
            this.#DB.run(`
                INSERT INTO "${this.#tablenm}"
                ( key, value )
                VALUES (
                    $key, $value
                )
            `, {
                $key: key,
                $value: JSON.stringify(value)
            }, (err) => {
                if (err) {
                    console.error(`put ERROR `, err.stack);
                    reject(err);
                }
                else {
                    resolve(undefined);
                }
            });
        });
        // console.log(`did put ${key}`);
    }
    async update(key, value) {
        // console.log(`to update ${key}`, value);
        const that = this;
        const result = await new Promise((resolve, reject) => {
            that.#DB.run(`
                UPDATE ${this.#tablenm}
                   SET value = $value
                 WHERE key = $key
            `, {
                $key: key,
                $value: JSON.stringify(value)
            }, (err) => {
                if (err) {
                    console.error(`update ERROR`, err.stack);
                    reject(err);
                }
                else
                    resolve(undefined);
            });
        });
        // console.log(`updated ${key}`);
    }
    async get(key) {
        // ... get item from table
        // console.log(`get ${key}`);
        const that = this;
        const result = await new Promise((resolve, reject) => {
            that.#DB.all(`
                SELECT value
                  FROM ${this.#tablenm}
                 WHERE key = $key
            `, {
                // $tablenm: this.#tablenm,
                $key: key
            }, (err, rows) => {
                if (err)
                    reject(err);
                else
                    resolve(rows);
            });
        });
        // console.log(`got ${key}`, result);
        if (Array.isArray(result)
            && result.length === 1) {
            const v1 = result[0];
            if (typeof v1 === 'object'
                && 'value' in v1
                && typeof v1['value'] === 'string') {
                return JSON.parse(v1['value']);
            }
            else {
                throw new Error(`Database had incorrect value field for ${key} ${util.inspect(v1)}`);
            }
        }
        else if (Array.isArray(result)
            && result.length > 1) {
            throw new Error(`Got more than one item for ${key} -- ${util.inspect(result)}`);
        }
        return undefined;
    }
    /**
     *
     * [
     *  { '$.foo.bar': 'value' },
     *  { '$.foo.bar1': 'value1' },
     *  { '$OR': [
     *     { '$.foo.zab': { gt: 'value } }
     *  ] }
     * ]
     *
     *
     * {
     *  '$.foo.bar': 'value',
     *  '$.foo.bar1': 'value1'
     *  '$.foo.bar2': { lt: 'value' },
     *  '$OR': [
     *  ]
     * }
     *
     * @param selector
     */
    async find(selectors) {
        let where = selectors2where(selectors);
        // console.log(where);
        const query = `
                SELECT key, value
                  FROM ${this.#tablenm}
                 WHERE ${where}
            `;
        // console.log(query);
        try {
            const that = this;
            const rows = await new Promise((resolve, reject) => {
                that.#DB.all(query, {}, (err, rows) => {
                    if (err)
                        reject(err);
                    else
                        resolve(rows);
                });
            });
            // console.log(`find ${util.inspect(rows)}`);
            return rows.map(row => {
                return JSON.parse(row.value);
            });
        }
        catch (err) {
            console.log(`find ERROR `, err.stack);
            throw err;
        }
    }
    async findAll() {
        const query = `
                SELECT key, value
                  FROM ${this.#tablenm}
            `;
        const that = this;
        const rows = await new Promise((resolve, reject) => {
            that.#DB.all(query, {}, (err, rows) => {
                if (err)
                    reject(err);
                else
                    resolve(rows);
            });
        });
        return rows.map(row => {
            return JSON.parse(row.value);
        });
    }
    async delete(key) {
        // .. delete item from table
        await new Promise((resolve, reject) => {
            this.#DB.run(`
                DELETE
                  FROM ${this.#tablenm}
                 WHERE key = $key
            `, {
                // $tablenm: this.#tablenm,
                $key: key
            }, (err) => {
                if (err) {
                    console.error(`delete ERROR`, err.stack);
                    reject(err);
                }
                else {
                    resolve(undefined);
                }
            });
        });
    }
    async drop() {
        // ... DROP TABLE
        await new Promise((resolve, reject) => {
            this.#DB.run(`
                DROP TABLE ${this.#tablenm}
            `, {}, (err) => {
                if (err) {
                    console.error(`delete ERROR`, err.stack);
                    reject(err);
                }
                else {
                    resolve(undefined);
                }
            });
        });
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQ0EsT0FBTyxJQUFJLE1BQU0sV0FBVyxDQUFDO0FBQzdCLE9BQU8sT0FBTyxNQUFNLFNBQVMsQ0FBQztBQUM5QixPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0sYUFBYSxDQUFDO0FBQzlDLGdDQUFnQztBQUVoQyw2Q0FBNkM7QUFDN0MseUNBQXlDO0FBQ3pDLHdDQUF3QztBQUN4QyxtQkFBbUI7QUFDbkIsRUFBRTtBQUNGLDBDQUEwQztBQUMxQywyQ0FBMkM7QUFDM0MsOENBQThDO0FBQzlDLFVBQVU7QUFDVixFQUFFO0FBQ0YsNENBQTRDO0FBQzVDLCtDQUErQztBQUcvQyxxQ0FBcUM7QUFDckMsa0NBQWtDO0FBQ2xDLCtCQUErQjtBQUUvQiw0QkFBNEI7QUFDNUIsY0FBYztBQUNkLGdCQUFnQjtBQUNoQixJQUFJO0FBQ0osdUNBQXVDO0FBQ3ZDLFlBQVk7QUFFWix1Q0FBdUM7QUFDdkMsaUNBQWlDO0FBRWpDLDJDQUEyQztBQUMzQywwQ0FBMEM7QUFDMUMsa0JBQWtCO0FBRWxCLGtEQUFrRDtBQUNsRCxtQ0FBbUM7QUFDbkMsMENBQTBDO0FBQzFDLHdDQUF3QztBQUV4QyxnREFBZ0Q7QUFDaEQsNENBQTRDO0FBQzVDLGFBQWE7QUFFYiw4Q0FBOEM7QUFDOUMsdUJBQXVCO0FBR3ZCLDJCQUEyQjtBQUMzQiw0QkFBNEI7QUFDNUIsZ0NBQWdDO0FBQ2hDLG1CQUFtQjtBQUduQixrQkFBa0I7QUFDbEIsZUFBZTtBQUNmLDJEQUEyRDtBQUMzRCxpQkFBaUI7QUFDakIsd0NBQXdDO0FBRXhDLDhDQUE4QztBQUU5Qyw0QkFBNEI7QUFFNUI7OztHQUdHO0FBQ0gsZ0RBQWdEO0FBQ2hELGVBQWU7QUFDZixJQUFJO0FBRUo7Ozs7O0dBS0c7QUFDSCx3Q0FBd0M7QUFDeEMsd0NBQXdDO0FBQ3hDLElBQUk7QUFFSixvQ0FBb0M7QUFF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LEdBQUcsRUFBRSxFQUFFO2dCQUNKLElBQUksR0FBRyxFQUFFLENBQUM7b0JBQ04sT0FBTyxDQUFDLEtBQUssQ0FBQyxjQUFjLEVBQUUsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO29CQUN6QyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7Z0JBQ2hCLENBQUM7cUJBQU0sQ0FBQztvQkFDSixPQUFPLENBQUMsU0FBUyxDQUFDLENBQUM7Z0JBQ3ZCLENBQUM7WUFDTCxDQUFDLENBQUMsQ0FBQztRQUNQLENBQUMsQ0FBQyxDQUFDO0lBQ1AsQ0FBQztDQUNKIiwic291cmNlc0NvbnRlbnQiOlsiXG5pbXBvcnQgdXRpbCBmcm9tICdub2RlOnV0aWwnO1xuaW1wb3J0IHNxbGl0ZTMgZnJvbSAnc3FsaXRlMyc7XG5pbXBvcnQgeyBzZWxlY3RvcnMyd2hlcmUgfSBmcm9tICcuL2ZpbmRlci5qcyc7XG4vLyBpbXBvcnQgc3FkYiBmcm9tICcuL3NxZGIuanMnO1xuXG4vLyBQUk9CTEVNIC0gQGFrYXNoYWNtcy9wbHVnbnMtdGFnZ2VkLWNvbnRlbnRcbi8vIGlzIHVzaW5nIFBvdWNoREIgd2hpY2ggdGhlbiBicm91Z2h0IGluXG4vLyBhIGxvdCBvZiB1bndhbnRlZCBkZXBlbmRlbmNpZXMgaW4gdGhlXG4vLyBMZXZlbERvd24gYXJlbmEuXG4vL1xuLy8gSXQgc2hvdWxkIGJlIHBvc3NpYmxlIHRvIHVzZSBTUUxJVEUzIHRvXG4vLyBpbXBsZW1lbnQgYSBrZXkvdmFsdWUgc3RvcmUuICBUaGlzIGNvdWxkXG4vLyBhbHNvIGVsaW1pbmF0ZSB0aGUgbmVlZCBmb3IgS2V5ViBpbiBhbm90aGVyXG4vLyBwbHVnaW4uXG4vL1xuLy8gQW5vdGhlciBnb2FsIGlzIHRvIHNwaW4gdGhpcyBvZmYgaW50byBpdHNcbi8vIG93biBwYWNrYWdlIHRoYXQgbWlnaHQgYmUgb2YgYnJvYWQgaW50ZXJlc3QuXG5cblxuLy8gU2ltcGxlIGtleS92YWx1ZSBzdG9yZSBvbiBTUUxJVEUzLlxuLy8gU3VwcG9ydCBtdWx0aXBsZSBzdG9yZXMgLSBuYW1lZFxuLy8gRWFjaCBzdG9yZSBoYXMgaXRzIG93biB0YWJsZVxuXG4vLyBDUkVBVEUgVEFCTEUga3ZzJHtOQU1FfSAoXG4vLyAgICBrZXkgVEVYVFxuLy8gICAgdmFsdWUgSlNPTlxuLy8gKVxuLy8gVGhlIGtleSBjb2x1bW4gbmVlZHMgYW4gaW5kZXggYW5kIHRvXG4vLyBiZSB1bmlxdWVcblxuLy8gSXMgdGhlcmUgYSB3YXkgdG8gQUxURVIgVEFCTEUgdG8gYWRkXG4vLyBjb2x1bW5zIGJhc2VkIG9uIGEgSlNPTiBmaWVsZD9cblxuLy8gVG8gcmVwbGFjZSBwb3VjaGRiIHVzZSBpbiB0YWdnZWQtY29udGVudFxuLy8gdGhlcmUncyBhIG5lZWQgZm9yIHF1ZXJpZXMgb24gZmllbGRzIG9mXG4vLyB0aGUgSlNPTiBvYmplY3RcblxuLy8gVGhpcyBlbmNhcHN1bGF0ZXMgYW4gb2JqZWN0IHdpdGggcHV0L2dldC9kZWxldGVcbi8vIG1ldGhvZHMgZm9yIHRoZSBrZXktdmFsdWUtc3RvcmUuXG4vLyBJZiBBTFRFUiBUQUJMRSBpcyB1c2VmdWwgdGhlbiBhbiBBUEkgaXNcbi8vIG5lZWRlZCBmb3IgYWRkaW5nIGEgcXVlcnlhYmxlIGNvbHVtbi5cblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2t1amlyYWhhbmQvbm9kZS1zcWxpdGUta3ZzXG4vLyBUaGF0J3MgYSBzaW1wbGlzdGljIEtWUyB3aGljaCBjYW4gYmUgdXNlZFxuLy8gYXMgYSBtb2RlbFxuXG4vLyBPbmNlIHRoaXMgaXMgY29tcGxldGUgaXQgY2FuIGJlIHNwdW4gb2ZmIHRvXG4vLyBhIHN0YW5kYWxvbmUgbW9kdWxlLlxuXG5cbi8vIENSRUFURSBUQUJMRSBrdnN7TkFNRX0gKFxuLy8gICAgIGtleSBURVhUIFBSSU1BUlkgS0VZLFxuLy8gICAgIHZhbHVlIEpTT04gLy8gaXNKU09OPXRydWVcbi8vICkgV0lUSE9VVCBST1dJRDtcblxuXG4vLyBzcWxpdGU+IFNFTEVDVCBcbi8vICAgICAgIHZwYXRoLFxuLy8gICAgICAganNvbl9leHRyYWN0KGluZm8sICckLnJlbmRlclBhdGgnKSBhcyByZW5kZXJQYXRoMiBcbi8vIEZST00gRE9DVU1FTlRTXG4vLyBXSEVSRSByZW5kZXJQYXRoMiBMSUtFICclaW5kZXguaHRtbCc7XG5cbi8vLy8vLy8vLy8vLy8vLy8vLyBPcGVuaW5nIERhdGFiYXNlIGNvbm5lY3Rpb25cblxuLy8gbGV0IERCOiBzcWxpdGUzLkRhdGFiYXNlO1xuXG4vKipcbiAqIFVzZSBhbiBleGlzdGluZyBEQlxuICogQHBhcmFtIGRiIFxuICovXG4vLyBleHBvcnQgZnVuY3Rpb24gdXNlREIoZGI6IHNxbGl0ZTMuRGF0YWJhc2UpIHtcbi8vICAgICBEQiA9IGRiO1xuLy8gfVxuXG4vKipcbiAqIE9wZW4gYSBkYXRhYmFzZSBjb25uZWN0aW9uIHRvIHRoZVxuICogbmFtZWQgbG9jYXRpb24uXG4gKlxuICogQHBhcmFtIGRidXJsIFxuICovXG4vLyBleHBvcnQgZnVuY3Rpb24gb3BlbihkYnVybDogc3RyaW5nKSB7XG4vLyAgICAgREIgPSBuZXcgc3FsaXRlMy5EYXRhYmFzZShkYnVybCk7XG4vLyB9XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLyBDcmVhdGUgYSB0YWJsZVxuXG4vLyBleHBvcnQgYXN5bmMgZnVuY3Rpb24ga3Z0YWJsZShuYW1lOiBzdHJpbmcpIHtcbi8vICAgICBjb25zdCB0YWJsZW5tID0gYGt2JHtuYW1lfWA7XG4vLyAgICAgY29uc3QgaW5kZXhubSA9IGBrdl9pbmRleF8ke25hbWV9YDtcbi8vICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBEQi5leGVjKGBcbi8vICAgICAgICAgQ1JFQVRFIFRBQkxFICR7dGFibGVubX0gKFxuLy8gICAgICAgICAgICAga2V5IFRFWFQgUFJJTUFSWSBLRVksXG4vLyAgICAgICAgICAgICB2YWx1ZSBURVhUXG4vLyAgICAgICAgICkgV0lUSE9VVCBST1dJRDtcbi8vICAgICAgICAgQ1JFQVRFIFVOSVFVRSBJTkRFWCAke2luZGV4bm19XG4vLyAgICAgICAgICAgICBPTiAke3RhYmxlbm19IChrZXkpO1xuLy8gICAgIGApO1xuXG4vLyAgICAgcmV0dXJuIG5ldyBTUTNEYXRhU3RvcmUoREIsIHRhYmxlbm0pO1xuLy8gfVxuXG5leHBvcnQgY2xhc3MgU1EzRGF0YVN0b3JlIHtcblxuICAgICNEQjogc3FsaXRlMy5EYXRhYmFzZTtcbiAgICAjdGFibGVubTogc3RyaW5nO1xuICAgICNpbmRleG5tOiBzdHJpbmc7XG5cbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgICAgIERCOiBzcWxpdGUzLkRhdGFiYXNlIHwgc3RyaW5nLFxuICAgICAgICAgICAgdGFibGVubTogc3RyaW5nKSB7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBEQiA9PT0gJ29iamVjdCdcbiAgICAgICAgICYmIERCIGluc3RhbmNlb2Ygc3FsaXRlMy5EYXRhYmFzZVxuICAgICAgICApIHtcbiAgICAgICAgICAgIHRoaXMuI0RCID0gREI7XG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIERCID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy4jREIgPSBuZXcgc3FsaXRlMy5EYXRhYmFzZShEQik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiNEQiA9IG5ldyBzcWxpdGUzLkRhdGFiYXNlKCc6bWVtb3J5OicpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGhpcy4jREIub24oJ3RyYWNlJywgKHNxbCkgPT4ge1xuICAgICAgICAvLyAgICAgY29uc29sZS5sb2coYFRSQUNFOiAke3NxbH1gKTtcbiAgICAgICAgLy8gfSk7XG5cbiAgICAgICAgdGhpcy4jdGFibGVubSA9IHRhYmxlbm07XG5cbiAgICAgICAgdGhpcy4jaW5kZXhubSA9IGBrdl9pbmRleF8ke3RhYmxlbm19YDtcbiAgICAgICAgdGhpcy4jREIuZXhlYyhgXG4gICAgICAgICAgICBDUkVBVEUgVEFCTEUgJHt0YWJsZW5tfSAoXG4gICAgICAgICAgICAgICAga2V5IFRFWFQgUFJJTUFSWSBLRVksXG4gICAgICAgICAgICAgICAgdmFsdWUgVEVYVFxuICAgICAgICAgICAgKSBXSVRIT1VUIFJPV0lEO1xuICAgICAgICAgICAgQ1JFQVRFIFVOSVFVRSBJTkRFWCAke3RoaXMuI2luZGV4bm19XG4gICAgICAgICAgICAgICAgT04gJHt0aGlzLiN0YWJsZW5tfSAoa2V5KTtcbiAgICAgICAgYCk7XG5cbiAgICB9XG5cbiAgICBnZXQgREIoKTogc3FsaXRlMy5EYXRhYmFzZSB7IHJldHVybiB0aGlzLiNEQjsgfVxuXG4gICAgLy8gVGhpcyBjYW4gYmUgdXNlZnVsIGZvciBkZWJ1Z2dpbmcuXG4gICAgLy8gVGhpcyBTUUxJVEUgcXVlcnkgcmV0cmlldmVzIHRoZSB0YWJsZSBsaXN0aW5nXG4gICAgLy8gYWxsIHRoZSBleGlzdGluZyB0YWJsZXMuXG5cbiAgICAvLyBhc3luYyB0YWJsZXMoKSB7XG4gICAgLy8gICAgIGNvbnN0IHJvd3MgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgLy8gICAgICAgICB0aGlzLiNEQi5hbGwoYFxuICAgIC8vICAgICAgICAgICAgIFNFTEVDVCAqIEZST00gc3FsaXRlX21hc3RlcjtcbiAgICAvLyAgICAgICAgIGAsIHt9LFxuICAgIC8vICAgICAgICAgKGVyciwgcm93cykgPT4ge1xuICAgIC8vICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAvLyAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgcHV0IEVSUk9SIGAsIGVyci5zdGFjayk7XG4gICAgLy8gICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgIC8vICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgLy8gICAgICAgICAgICAgICAgIHJlc29sdmUocm93cyk7XG4gICAgLy8gICAgICAgICAgICAgfVxuICAgIC8vICAgICAgICAgfSk7XG4gICAgLy8gICAgIH0pO1xuICAgIC8vICAgICByZXR1cm4gcm93cztcbiAgICAvLyB9XG5cbiAgICBhc3luYyBwdXQoa2V5OiBzdHJpbmcsIHZhbHVlOiBhbnkpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgLy8gaW5zZXJ0IGludG8gLi4uXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGBiZWZvcmUgZ2V0ICR7a2V5fWApO1xuICAgICAgICBjb25zdCB1cGRhdGUgPSBhd2FpdCB0aGlzLmdldChrZXkpO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhgcHV0ICR7a2V5fSBnb3QgdmFsdWUgJHt1dGlsLmluc3BlY3QodXBkYXRlKX1gKTtcbiAgICAgICAgaWYgKHVwZGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMudXBkYXRlKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGB0byBwdXQgJHtrZXl9YCwgdmFsdWUpO1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGlzLiNEQi5ydW4oYFxuICAgICAgICAgICAgICAgIElOU0VSVCBJTlRPIFwiJHt0aGlzLiN0YWJsZW5tfVwiXG4gICAgICAgICAgICAgICAgKCBrZXksIHZhbHVlIClcbiAgICAgICAgICAgICAgICBWQUxVRVMgKFxuICAgICAgICAgICAgICAgICAgICAka2V5LCAkdmFsdWVcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICBgLCB7XG4gICAgICAgICAgICAgICAgJGtleToga2V5LFxuICAgICAgICAgICAgICAgICR2YWx1ZTogSlNPTi5zdHJpbmdpZnkodmFsdWUpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgcHV0IEVSUk9SIGAsIGVyci5zdGFjayk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkgXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGBkaWQgcHV0ICR7a2V5fWApO1xuICAgIH1cblxuICAgIGFzeW5jIHVwZGF0ZShrZXk6IHN0cmluZywgdmFsdWU6IGFueSk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhgdG8gdXBkYXRlICR7a2V5fWAsIHZhbHVlKTtcbiAgICAgICAgY29uc3QgdGhhdCA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoYXQuI0RCLnJ1bihgXG4gICAgICAgICAgICAgICAgVVBEQVRFICR7dGhpcy4jdGFibGVubX1cbiAgICAgICAgICAgICAgICAgICBTRVQgdmFsdWUgPSAkdmFsdWVcbiAgICAgICAgICAgICAgICAgV0hFUkUga2V5ID0gJGtleVxuICAgICAgICAgICAgYCwge1xuICAgICAgICAgICAgICAgICRrZXk6IGtleSxcbiAgICAgICAgICAgICAgICAkdmFsdWU6IEpTT04uc3RyaW5naWZ5KHZhbHVlKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYHVwZGF0ZSBFUlJPUmAsIGVyci5zdGFjayk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSByZXNvbHZlKHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGB1cGRhdGVkICR7a2V5fWApO1xuICAgIH1cblxuICAgIGFzeW5jIGdldChrZXk6IHN0cmluZyk6IFByb21pc2U8YW55IHwgdW5kZWZpbmVkPiB7XG4gICAgICAgIC8vIC4uLiBnZXQgaXRlbSBmcm9tIHRhYmxlXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKGBnZXQgJHtrZXl9YCk7XG4gICAgICAgIGNvbnN0IHRoYXQgPSB0aGlzO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0aGF0LiNEQi5hbGwoYFxuICAgICAgICAgICAgICAgIFNFTEVDVCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgRlJPTSAke3RoaXMuI3RhYmxlbm19XG4gICAgICAgICAgICAgICAgIFdIRVJFIGtleSA9ICRrZXlcbiAgICAgICAgICAgIGAsIHtcbiAgICAgICAgICAgICAgICAvLyAkdGFibGVubTogdGhpcy4jdGFibGVubSxcbiAgICAgICAgICAgICAgICAka2V5OiBrZXlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAoZXJyLCByb3dzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgZWxzZSByZXNvbHZlKHJvd3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhgZ290ICR7a2V5fWAsIHJlc3VsdCk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdClcbiAgICAgICAgICYmIHJlc3VsdC5sZW5ndGggPT09IDFcbiAgICAgICAgKSB7XG4gICAgICAgICAgICBjb25zdCB2MSA9IHJlc3VsdFswXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdjEgPT09ICdvYmplY3QnXG4gICAgICAgICAgICAgJiYgJ3ZhbHVlJyBpbiB2MVxuICAgICAgICAgICAgICYmIHR5cGVvZiB2MVsndmFsdWUnXSA9PT0gJ3N0cmluZydcbiAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHYxWyd2YWx1ZSddKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBEYXRhYmFzZSBoYWQgaW5jb3JyZWN0IHZhbHVlIGZpZWxkIGZvciAke2tleX0gJHt1dGlsLmluc3BlY3QodjEpfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0KVxuICAgICAgICAgICAgJiYgcmVzdWx0Lmxlbmd0aCA+IDFcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEdvdCBtb3JlIHRoYW4gb25lIGl0ZW0gZm9yICR7a2V5fSAtLSAke3V0aWwuaW5zcGVjdChyZXN1bHQpfWApO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFxuICAgICAqIFtcbiAgICAgKiAgeyAnJC5mb28uYmFyJzogJ3ZhbHVlJyB9LFxuICAgICAqICB7ICckLmZvby5iYXIxJzogJ3ZhbHVlMScgfSxcbiAgICAgKiAgeyAnJE9SJzogW1xuICAgICAqICAgICB7ICckLmZvby56YWInOiB7IGd0OiAndmFsdWUgfSB9XG4gICAgICogIF0gfVxuICAgICAqIF1cbiAgICAgKiBcbiAgICAgKiBcbiAgICAgKiB7XG4gICAgICogICckLmZvby5iYXInOiAndmFsdWUnLFxuICAgICAqICAnJC5mb28uYmFyMSc6ICd2YWx1ZTEnXG4gICAgICogICckLmZvby5iYXIyJzogeyBsdDogJ3ZhbHVlJyB9LFxuICAgICAqICAnJE9SJzogW1xuICAgICAqICBdXG4gICAgICogfVxuICAgICAqIFxuICAgICAqIEBwYXJhbSBzZWxlY3RvciBcbiAgICAgKi9cbiAgICBhc3luYyBmaW5kKHNlbGVjdG9yczogYW55KVxuICAgICAgICA6IFByb21pc2U8QXJyYXk8YW55PiB8IHVuZGVmaW5lZD5cbiAgICB7XG4gICAgICAgIGxldCB3aGVyZSA9IHNlbGVjdG9yczJ3aGVyZShzZWxlY3RvcnMpO1xuXG4gICAgICAgIC8vIGNvbnNvbGUubG9nKHdoZXJlKTtcblxuICAgICAgICBjb25zdCBxdWVyeSA9IGBcbiAgICAgICAgICAgICAgICBTRUxFQ1Qga2V5LCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgRlJPTSAke3RoaXMuI3RhYmxlbm19XG4gICAgICAgICAgICAgICAgIFdIRVJFICR7d2hlcmV9XG4gICAgICAgICAgICBgO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhxdWVyeSk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHRoYXQgPSB0aGlzO1xuICAgICAgICAgICAgY29uc3Qgcm93cyA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICB0aGF0LiNEQi5hbGwocXVlcnksIHsgfSxcbiAgICAgICAgICAgICAgICAoZXJyLCByb3dzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIHJlc29sdmUocm93cyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KSBhcyBhbnlbXTtcblxuICAgICAgICAgICAgLy8gY29uc29sZS5sb2coYGZpbmQgJHt1dGlsLmluc3BlY3Qocm93cyl9YCk7XG4gICAgICAgICAgICByZXR1cm4gcm93cy5tYXAocm93ID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShyb3cudmFsdWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gY2F0Y2ggKGVycjogYW55KSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgZmluZCBFUlJPUiBgLCBlcnIuc3RhY2spO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXN5bmMgZmluZEFsbCgpOiBQcm9taXNlPEFycmF5PGFueT4+IHtcblxuICAgICAgICBjb25zdCBxdWVyeSA9IGBcbiAgICAgICAgICAgICAgICBTRUxFQ1Qga2V5LCB2YWx1ZVxuICAgICAgICAgICAgICAgICAgRlJPTSAke3RoaXMuI3RhYmxlbm19XG4gICAgICAgICAgICBgO1xuICAgICAgICBjb25zdCB0aGF0ID0gdGhpcztcbiAgICAgICAgY29uc3Qgcm93cyA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoYXQuI0RCLmFsbChxdWVyeSwgeyB9LFxuICAgICAgICAgICAgKGVyciwgcm93cykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIGVsc2UgcmVzb2x2ZShyb3dzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KSBhcyBhbnlbXTtcblxuICAgICAgICByZXR1cm4gcm93cy5tYXAocm93ID0+IHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnBhcnNlKHJvdy52YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGFzeW5jIGRlbGV0ZShrZXk6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xuICAgICAgICAvLyAuLiBkZWxldGUgaXRlbSBmcm9tIHRhYmxlXG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMuI0RCLnJ1bihgXG4gICAgICAgICAgICAgICAgREVMRVRFXG4gICAgICAgICAgICAgICAgICBGUk9NICR7dGhpcy4jdGFibGVubX1cbiAgICAgICAgICAgICAgICAgV0hFUkUga2V5ID0gJGtleVxuICAgICAgICAgICAgYCwge1xuICAgICAgICAgICAgICAgIC8vICR0YWJsZW5tOiB0aGlzLiN0YWJsZW5tLFxuICAgICAgICAgICAgICAgICRrZXk6IGtleVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYGRlbGV0ZSBFUlJPUmAsIGVyci5zdGFjayk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYXN5bmMgZHJvcCgpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICAgICAgLy8gLi4uIERST1AgVEFCTEVcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy4jREIucnVuKGBcbiAgICAgICAgICAgICAgICBEUk9QIFRBQkxFICR7dGhpcy4jdGFibGVubX1cbiAgICAgICAgICAgIGAsIHsgfSxcbiAgICAgICAgICAgIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoYGRlbGV0ZSBFUlJPUmAsIGVyci5zdGFjayk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufSJdfQ==